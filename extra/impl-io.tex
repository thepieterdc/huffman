\subsection{Input- en Outputverwerking}
Aangezien \emph{input} en \emph{output} de twee grootste bottlenecks van het programma waren heb ik deze geoptimaliseerd. Bij de inputverwerking is de grootste optimalisatie het gebruik van de \emph{thread unsafe} variant van \emph{fread}. Bij de output maak ik hier ook gebruik van. Het feit dat deze varianten \emph{thread unsafe} zijn is geen probleem aangezien er bij het begin van programma een \emph{lock} wordt genomen op het input en outputkanaal. Het wegschrijven van bits gebeurt door het systematisch vullen van een interne buffer van 64 bits lang en deze, eens volledig gevuld, weg te schrijven met \emph{fwrite\_unlocked}. Hierbij was er nog het probleem dat \emph{fwrite} deze 64 bits print in \emph{most significant bit endianness}, dit wordt opgelost door de bits vooraleer ze geprint worden te swappen \cite{64bitswaps}. Het printen van karakters in de encoder gebeurt steeds met \emph{putc\_unlocked}, aangezien deze macro intern al een buffer bijhoudt. Waar mogelijk is mijn \emph{I/O}-bibliotheek ook met macro's ge\"implementeerd, voor minimaal verlies aan snelheid. Desondanks deze optimalisaties blijft \emph{I/O} en in het bijzonder de output, toch de grootste kost hebben. In een later stadium had ik geprobeerd dit nog meer low-level te maken door gebruik te maken van \emph{write}, maar dit bleek eerder een negatief effect op de snelheid te hebben.