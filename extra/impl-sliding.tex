\section{Adaptive Huffmancoding met sliding window}

\subsection{Downdate}
De \emph{downdate}-procedure is gebaseerd op de \emph{Adaptive Update}-procedure, maar dan omgekeerd, hetzelfde geldt voor de procedure om de wisseltop te bepalen. Indien er een top gewicht $0$ bereikt wordt deze verwijderd uit de boom. Nadat deze top verwijderd is is het belangrijk dat er gecontroleerd wordt dat \texttt{nng} de broer is van de top met het laagste gewicht en laagste ordernummer\footnote{Er wordt aangenomen dat de ordenummers op aflopende volgorde gesorteerd zijn; de wortel heeft het hoogste ordernummer.}. Indien dit niet het geval is zal de boom in een ongeldige toestand terecht komen wanneer een volgend karakter verwijderd wordt. 

\subsection{Grootte van het sliding window}
Knuth beschrijft in zijn paper \cite{knuthhuffman} wat de optimale windowgroottes zijn op pagina 180. Volgens de tabel ligt deze waarde op $1250$, maar zelf heb ik ook een aantal experimenten uitgevoerd om zo voor tekstuele data de optimale windowgrootte te bepalen. Onderstaande grafiek toont de compressieratio's\footnote{Compressieratio wordt gedefinieerd als $(\frac{c}{o})$ met $c,o$ respectievelijk de groottes van de gecomprimeerde tekst en de originele tekst, uitgedrukt in bytes.} De tests werden steeds uitgevoerd op 6 fragmenten uit de King James Bible \cite{gutenbergbible} met verschillende lengtes. De bestandsgroottes van deze bestanden zijn respectievelijk $\SI{100}{\byte}, \SI{1}{\kilo\byte}, \SI{10}{\kilo\byte}, \SI{100}{\kilo\byte}, \SI{1}{\mega\byte}$ en $\SI{10}{\mega\byte}$. Deze bestanden werden ge\"encodeerd voor verschillende windowgroottes, waarna het gemiddelde van de compressieratio's per windowgrootte werd bepaald en in de grafiek werd geplot. De laatste windowgrootte, $\infty$, verwijst naar de compressieratio bekomen door \emph{Adaptive Huffmancoding} zonder sliding window.